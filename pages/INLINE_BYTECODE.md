# Inline Bytecode
`
Note: Inline bytecode is an advanced feature, please do not use it unless you absolutely need it and be sure that your bytecode has 0 stack affect as the compiler will go off of that assumption.
`


## Instructions
### eq (equals to)
    info: checks if the top 2 values on the stack are equal to eachother

    usage: `eq`
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 


### neq (not equals to)
    info: checks if the top 2 values on the stack are not equal to eachother

    usage: `neq`
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 


### gt (greater than)
    info: checks if the value after the top value is greater than the top value

    usage: `gt`
    
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 
        - the top two values are of integer or float


### lt (less than)
    info: checks if the value after the top value is less than the top value

    usage: `lt`
    
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 
        - the top two values are of integer or float


### ge (greater equals)
    info: checks if the value after the top value is greater than or equals to the top value

    usage: `ge`
    
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 
        - the top two values are of integer or float


### le (lesser equals)
    info: checks if the value after the top value is lesser than or equals to the top value

    usage: `le`
    
    bytecode size: 1

    stack affect: ( x y -- b )
        - typeof b = bool

    expectations:
        - the top two values are of identical base-type 
        - the top two values are of integer or float


### jmp (jump)
    info: jumps a certain amount of bytes

    usage: `jmp [amount]`
    
    bytecode size: 2

    stack affect: ( -- )

    expectations:
        - the jumped amount is not larger than the generated bytecode
        - the jump amount is less than 256


### jif (jump if false)
    info: jumps back a certain amount of bytes if the top value is false

    usage: `jif [amount]`
    
    bytecode size: 2

    stack affect: ( x -- )

    expectations:
        - the jump does not result in a invalid code index
        - the top value on the stack is a bool
        - the jump amount is less than 256


### bjmp (back jump)
    info: jumps back a certain amount of bytes

    usage: `bjmp [amount]`
    
    bytecode size: 2

    stack affect: ( -- )

    expectations:
        - the jump does not result in a invalid code index
        - the jump amount is less than 256



### jmpl (jump large)
    info: jumps a certain amount of bytes

    usage: `jmpl [amount]`
    
    bytecode size: 3

    stack affect: ( -- )

    expectations:
        - the jumped amount is not larger than the generated bytecode
        - the jump amount is less than 65,536


### jifl (jump if false large)
    info: jumps back a certain amount of bytes if the top value is false

    usage: `jifl [amount]`
    
    bytecode size: 3

    stack affect: ( x -- )

    expectations:
        - the jump does not result in a invalid code index
        - the top value on the stack is a bool
        - the jump amount is less than 65,536


### bjmpl (back jump large)
    info: jumps back a certain amount of bytes

    usage: `bjmpl [amount]`
    
    bytecode size: 3

    stack affect: ( -- )

    expectations:
        - the jump does not result in a invalid code index
        - the jump amount is less than 65,536


### add (addition)
    info: adds the top 2 values on the stack and pushes the value

    usage: `add`
    
    bytecode size: 1

    stack affect: ( x y -- z )
        - typeof z = typeof x

    expectations:
        - the top two values are of the same base-type
        - the top two values are either an integer or a float


### sub (subtraction)
    info: subtracts the top value from the next value

    usage: `sub`
    
    bytecode size: 1

    stack affect: ( x y -- z )
        - typeof z = typeof x

    expectations:
        - the top two values are of the same base-type
        - the top two values are either an integer or a float


### mul (multiplication)
    info: multiplies the top 2 values on the stack and pushes the value

    usage: `mul`
    
    bytecode size: 1

    stack affect: ( x y -- z )
        - typeof z = typeof x

    expectations:
        - the top two values are of the same base-type
        - the top two values are either an integer or a float


### div (division)
    info: divides the top value with the next value

    usage: `div`
    
    bytecode size: 1

    stack affect: ( x y -- z )
        - typeof z = typeof x

    expectations:
        - the top two values are of the same base-type
        - the top two values are either an integer or a float


### takef (Take Fast)
    info: clones the value at a given index to the top of the stack, 

    usage: 'takef [index]'
    [!] the index is relative to the current function
    
    bytecode size: 2

    stack affect: ( -- z )

    expectations:
        - the index is a valid stack index
        - index is less than 256


### take (Take)
    info: clones the value at a given index to the top of the stack, 

    usage: 'take [index]'
    [!] the index is relative to the current function
    
    bytecode size: 3

    stack affect: ( -- x )

    expectations:
        - the index is a valid stack index
        - the index is less than 65,536


### repf (Replace Fast)
    info: replaces the value at a certain index

    usage: 'repf [index]'
    [!] the index is relative to the current function
    
    bytecode size: 2

    stack affect: ( x -- )

    expectations:
        - the index is a valid stack index
        - the index is less than 256


### rep (Replace)
    info: replaces the value at a certain index

    usage: 'rep [index]'
    [!] the index is relative to the current function
    
    bytecode size: 3

    stack affect: ( x -- )

    expectations:
        - the index is a valid stack index
        - the index is less than 65,536


### not (Not)
    info: gets the not value of the value on the top of the stack

    usage: 'not'
    
    bytecode size: 1

    stack affect: ( x -- z )
        - typeof z = typeof x

    expectations:
        - the value at the top of the stack is a bool


### neg (Negate)
    info: negates the value at the top of the stack

    usage: 'neg'
    
    bytecode size: 1

    stack affect: ( x -- z )
        - typeof z = typeof x

    expectations:
        - the value at the top of the stack is of type integer or float


### raw (Raw Call)
    info: calls a native function
    [!] this ignores all safety rules that native functions have, please make sure you are respecting the expectations of the native function you are calling

    usage: 'raw [index]'
    
    bytecode size: 2

    stack affect: ( ? -- ? )


### rot (Rotate)
    info: rotates the top 3 values on the stack

    usage: 'rot'
    
    bytecode size: 1

    stack affect: ( x y z -- y z x )


### over (Over)
    info: pushes the value that is at right below the top of the stack

    usage: 'over'
    
    bytecode size: 1

    stack affect: ( x y -- x y x )


### swap (Swap)
    info: swaps the top of the stack with the value below it

    usage: 'swap'
    
    bytecode size: 1

    stack affect: ( x y -- y x )


### iswap (Indexed Swap)
    info: swaps the values at an arbitrary index with a value at another arbitrary index

    usage: 'iswap [index] [index]'
    
    bytecode size: 3

    stack affect: ( x y -- y x )

    expectations:
        - both indexs is a valid stack index
        - both indexs is less than 255


### dup (Duplicate)
    info: duplicates and pushes the value at the top of the stack

    usage: 'dup'
    
    bytecode size: 1

    stack affect: ( x -- x x )


### inc (Increment)
    info: increments the value in place

    usage: 'inc'
    
    bytecode size: 1

    stack affect: ( x -- x )
